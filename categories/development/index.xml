<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on kodbasen</title>
    <link>http://larmog.github.io/categories/development/</link>
    <description>Recent content in Development on kodbasen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright Â© 2016 by larmog</copyright>
    <lastBuildDate>Thu, 04 Feb 2016 20:56:35 +0100</lastBuildDate>
    <atom:link href="http://larmog.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Thank you Java, but it&#39;s time to Go</title>
      <link>http://larmog.github.io/2016/02/04/thank-you-java-but-its-time-to-go/</link>
      <pubDate>Thu, 04 Feb 2016 20:56:35 +0100</pubDate>
      
      <guid>http://larmog.github.io/2016/02/04/thank-you-java-but-its-time-to-go/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been a dedicated Java developer since 1998 and it&amp;rsquo;s been a great tool.
But recently there&amp;rsquo;s a couple of things I&amp;rsquo;ve been fretting about. I always been
a slow using keyboard (never learnt how use it correctly). When programming
that&amp;rsquo;s not always a bad thing.
But Java is very verbose and all those &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;pubic&lt;/code&gt;, &lt;code&gt;;&lt;/code&gt;, &lt;code&gt;getXXX&lt;/code&gt;,
&lt;code&gt;setXXX&lt;/code&gt; kind of gets in the way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another thing that turns out to be complicated is coding standards. It&amp;rsquo;s all
well when your on a greenfield project and the team can decide their own rules.
But have you ever worked with legacy code that&amp;rsquo;s been abused for several years
buy developers who rather wish they were on that super cool project? I know you
can&amp;rsquo;t blame &lt;code&gt;Java&lt;/code&gt; for this but it&amp;rsquo;s still a problem. Coding standards are like
fashion and every developer has an opinion on where to put the &lt;code&gt;{}&lt;/code&gt; and don&amp;rsquo;t
mention line endings when your in a mixed Windows and *nix environment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Gofmt is a tool that automatically formats Go source code
$go fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Java was released in 1995 the promise &lt;em&gt;&amp;ldquo;write once, run anywhere&amp;rdquo;&lt;/em&gt; sounded
very tempting but has shown not to be altogether true. There have been, and
will always be, bugs and small differences in the JVM which means that your
program will always be dependent on the version of the JVM running your byte
code. That means you have at least two artifacts to consider and
one of them is out of your control.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Static compiled go binary that can be used in a Docker image.
# The binary is compiled using golang Docker image.
$CGO_ENABLED=0 GOOS=linux go build -ldflags &amp;quot;-s&amp;quot; -a -installsuffix cgo -o main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your like me feeling young and haven&amp;rsquo;t aged a day since 1995, the truth is
time goes by. Even if you do your best to keep young, it&amp;rsquo;s hard to change. Java
has done a good job: HotSpot, Regular expressions, NIO, Generics, Annotations,
primitive wrapper classes with autoboxing, Enumerations, Varargs and Lambda
Expressions. Just take a look at the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_version_history&#34;&gt;Java version history&lt;/a&gt;. But
all this adds up and gains weight. Java has become hard to learn and understand
and there are many pitfalls and compromises. Some times the right decision is
to start all over and make something new based on what you&amp;rsquo;ve learnt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# OSX
$open http://tour.golang.org/welcome/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m keeping Java in my toolbox but I&amp;rsquo;ve started using
&lt;a href=&#34;https://golang.org/&#34;&gt;The Go Programming Language&lt;/a&gt; as my new tool and
it&amp;rsquo;s great fun.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple Groovy AOP using MOP</title>
      <link>http://larmog.github.io/2014/08/18/simple-groovy-aop-using-mop/</link>
      <pubDate>Mon, 18 Aug 2014 21:37:45 +0100</pubDate>
      
      <guid>http://larmog.github.io/2014/08/18/simple-groovy-aop-using-mop/</guid>
      <description>&lt;p&gt;I was looking for a simple solution for adding cross cutting concerns to Groovy
classes. The most obvious solution was to implement &lt;code&gt;GroovyInterceptable&lt;/code&gt; but I wanted a
less intrusive solution. After a bit of googling I&amp;rsquo;ve stumbled across
&lt;code&gt;DelegatingMetaClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is a simple interceptor that works like a around advice. It only logs all method
calls for a class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Interceptor extends DelegatingMetaClass {
  	Interceptor(final Class cls) {
      	super(cls)
      	initialize()
  	}

  	public Object invokeMethod(Object obj, String method, Object[] args) {
      	String cls = obj.class.simpleName
      	println &amp;quot;before: $cls.$method, args:$args --&amp;gt;&amp;quot;
      	def val = null
      	try {
          	val = super.invokeMethod(obj, method, args)
      	} catch(Exception e) {
          	println &amp;quot;after: $cls.$method, has thrown:$e &amp;lt;--&amp;quot;
          	throw e
      	}
      	println &amp;quot;after: $cls.$method, return value:$val &amp;lt;--&amp;quot;
      	return val;
  	}

  	def static injectIn(Class cls) {
      	cls.metaClass = new Interceptor(cls)
  	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use the &lt;code&gt;Interceptor&lt;/code&gt; to trace calls to &lt;code&gt;ArrayList&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	Interceptor.InjectIn(ArrayList)

	def list = []
	list &amp;lt;&amp;lt; &amp;quot;Joe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the above it will produce:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;	before: ArrayList.leftShift, args:[Joe] --&amp;gt;
	after: ArrayList.leftShift, return value:[Joe] &amp;lt;--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works width mixin&amp;rsquo;s too, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	class Person {
		def name

		def sayHello() { println &amp;quot;Hi, my name is $name!&amp;quot;}
	}

	class Dancer {
		def dance() { println &amp;quot;I can dance&amp;quot; }
	}

	class Singer {
		def sing() { println &amp;quot;I can sing&amp;quot; }
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now create a person who dance and sing. The &lt;code&gt;Interceptor&lt;/code&gt; must be injected
after the mixin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	Person.mixin Singer
	Person.mixin Dancer
	Interceptor.injectIn(Person)

	def p = new Person(name: &amp;quot;Jill&amp;quot;)
	p.sayHello()
	p.sing()
	p.dance()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;	before: Person.sayHello, args:[] --&amp;gt;
	before: Person.println, args:[Hi, my name is Jill!] --&amp;gt;
	Hi, my name is Jill!
	after: Person.println, return value:null &amp;lt;--
	after: Person.sayHello, return value:null &amp;lt;--
	before: Person.sing, args:[] --&amp;gt;
	I can sing
	after: Person.sing, return value:null &amp;lt;--
	before: Person.dance, args:[] --&amp;gt;
	I can dance
	after: Person.dance, return value:null &amp;lt;--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see in the example above the &lt;code&gt;println&lt;/code&gt;-method is part of the Groovy object.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>