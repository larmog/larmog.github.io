<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[larmog blog]]></title>
  <link href="http://larmog.github.io/atom.xml" rel="self"/>
  <link href="http://larmog.github.io/"/>
  <updated>2014-02-18T16:38:30+01:00</updated>
  <id>http://larmog.github.io/</id>
  <author>
    <name><![CDATA[Lars Mogren]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple Groovy AOP Using MOP]]></title>
    <link href="http://larmog.github.io/blog/2014/02/18/simple-groovy-aop-using-mop/"/>
    <updated>2014-02-18T10:23:00+01:00</updated>
    <id>http://larmog.github.io/blog/2014/02/18/simple-groovy-aop-using-mop</id>
    <content type="html"><![CDATA[<p>I was looking for a simple solution for adding cross cutting concernes to Groovy
classes. The most obvious solution was to implement <code>GroovyInterceptable</code> but I wanted a
less intrusive solution. After a bit of googling I&rsquo;ve stumbled across
<code>DelegatingMetaClass</code>.</p>

<p>Here is a simple interceptor that works like a around advice. It only logs all method
calls for a class.</p>

<pre><code>class Interceptor extends DelegatingMetaClass {
    Interceptor(final Class cls) {
        super(cls)
        initialize()
    }

    public Object invokeMethod(Object obj, String method, Object[] args) {
        String cls = obj.class.simpleName
        println "before: $cls.$method, args:$args --&gt;"
        def val = null
        try {
            val = super.invokeMethod(obj, method, args)
        } catch(Exception e) {
            println "after: $cls.$method, has thrown:$e &lt;--"
            throw e
        }
        println "after: $cls.$method, return value:$val &lt;--"
        return val;
    }

    def static injectIn(Class cls) {
        cls.metaClass = new Interceptor(cls)
    }
}
</code></pre>

<p>We can now use the <code>Interceptor</code> to trace calls to <code>ArrayList</code> like this:</p>

<pre><code>Interceptor.InjectIn(ArrayList)

def list = []
list &lt;&lt; "Joe"
</code></pre>

<p>If we run the above it will produce:</p>

<pre><code>before: ArrayList.leftShift, args:[Joe] --&gt;
after: ArrayList.leftShift, return value:[Joe] &lt;--
</code></pre>

<p>It works width mixin&rsquo;s too, for example:</p>

<pre><code>class Person {
    def name

    def sayHello() { println "Hi, my name is $name!"}
}

class Dancer {
    def dance() { println "I can dance" }
}

class Singer {
    def sing() { println "I can sing" }
}
</code></pre>

<p>We can now create a person who dance and sing. The <code>Interceptor</code> must be injected
after the mixin:</p>

<pre><code>Person.mixin Singer
Person.mixin Dancer
Interceptor.injectIn(Person)

def p = new Person(name: "Jill")
p.sayHello()
p.sing()
p.dance()
</code></pre>

<p>This will produce the following output:</p>

<pre><code>before: Person.sayHello, args:[] --&gt;
before: Person.println, args:[Hi, my name is Jill!] --&gt;
Hi, my name is Jill!
after: Person.println, return value:null &lt;--
after: Person.sayHello, return value:null &lt;--
before: Person.sing, args:[] --&gt;
I can sing
after: Person.sing, return value:null &lt;--
before: Person.dance, args:[] --&gt;
I can dance
after: Person.dance, return value:null &lt;--
</code></pre>

<p> As we can see in the example above the <code>println</code>-method is part of the Groovy object.</p>
]]></content>
  </entry>
  
</feed>
