<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on kodbasen</title>
    <link>http://larmog.github.io/tags/development/</link>
    <description>Recent content in Development on kodbasen</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Copyright © 2016 by larmog</copyright>
    <lastBuildDate>Sun, 07 Feb 2016 11:17:02 +0100</lastBuildDate>
    <atom:link href="http://larmog.github.io/tags/development/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gogs and Drone On Kubernetes-ARM - Part 1</title>
      <link>http://larmog.github.io/2016/02/07/gogs-and-drone-on-kubernetes-arm---part-1/</link>
      <pubDate>Sun, 07 Feb 2016 11:17:02 +0100</pubDate>
      
      <guid>http://larmog.github.io/2016/02/07/gogs-and-drone-on-kubernetes-arm---part-1/</guid>
      <description>&lt;p&gt;This is part 1 in a series of posts describing how I have setup Gogs and Drone
on my Kubernetes-ARM cluster. &lt;a href=&#34;https://gogs.io/&#34;&gt;Gogs - Go Git Service&lt;/a&gt; is
&lt;em&gt;A painless self-hosted Git service&lt;/em&gt; and is a great alternative when you can&amp;rsquo;t
use GitHub or wan&amp;rsquo;t to host your own Git service.&lt;/p&gt;

&lt;p&gt;The easiest way to get started with Gogs (and of course the only alternative if
you wan&amp;rsquo;t to use Kubernetes) is to use a Docker image. Gogs has a Docker image
ready on Docker Hub. Unfortunately that image won&amp;rsquo;t work on ARM.
Thankfully the Hypriot team has two Gogs Docker images ready: &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-gogs-raspbian/&#34;&gt;hypriot/rpi-gogs-raspbian&lt;/a&gt;
and &lt;a href=&#34;https://hub.docker.com/r/hypriot/rpi-gogs-alpine/&#34;&gt;hypriot/rpi-gogs-alpine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Lets try it out:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl run my-gogs-service --image=hypriot/rpi-gogs-alpine --replicas=1 --port=3000
replicationcontroller &amp;quot;my-gogs-service&amp;quot; created
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we can see our pod is running:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get pods
NAME                      READY     STATUS    RESTARTS   AGE
my-gogs-service-3adh8     1/1       Running   0          1m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s time to expose our new pod as a service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl expose rc my-gogs-service --port=80 --target-port=3000 --name=my-gogs-service
service &amp;quot;my-gogs-service&amp;quot; exposed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If all went well we can now access or new service:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -s http://[master-ip]:8080/api/v1/proxy/namespaces/default/services/my-gogs-service/install|grep Version:
&amp;lt;p class=&amp;quot;left&amp;quot; id=&amp;quot;footer-rights&amp;quot;&amp;gt;© 2015 Gogs · Version: 0.6.1.0325 Beta Page:&amp;lt;strong&amp;gt;2259ms&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But oops! that´s kind of an old version. Our goal is to use Gogs together with
Drone and this won&amp;rsquo;t work. We need a version greater than &lt;code&gt;0.6.16.1022&lt;/code&gt;
(&lt;a href=&#34;http://readme.drone.io/setup/gogs/&#34;&gt;see&lt;/a&gt;). I guess this is the difference
between &lt;em&gt;leading edge&lt;/em&gt; and &lt;em&gt;bleeding edge&lt;/em&gt;. Again we&amp;rsquo;re saved by some one else&amp;rsquo;s
work. Gogs has a &lt;code&gt;Dockerfile.rpi&lt;/code&gt; ready that we can use to build our own image.
I&amp;rsquo;ve built and pushed an image to Docker Hub that you can use:
&lt;a href=&#34;https://hub.docker.com/r/larmog/rpi-gogs/&#34;&gt;&lt;code&gt;larmog/rpi-gogs&lt;/code&gt;&lt;/a&gt; that is &lt;code&gt;33MB&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So lets repeat the steps above with the new image and &lt;code&gt;curl&lt;/code&gt; for the version:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ curl -s http://[master-ip]:8080/api/v1/proxy/namespaces/default/services/my-gogs-service/install|grep Version
© 2016 Gogs Version: 0.8.23.0126 Page: &amp;lt;strong&amp;gt;1622ms&amp;lt;/strong&amp;gt; Template: &amp;lt;strong&amp;gt;1619ms&amp;lt;/strong&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Version &lt;code&gt;0.8.23.0126&lt;/code&gt;, that looks so much better don&amp;rsquo;t, you think?&lt;/p&gt;

&lt;p&gt;Next step is to install Gogs. But hey&amp;hellip; wait a minute - what about persistence?
We need to add a &lt;em&gt;Volume&lt;/em&gt;. I&amp;rsquo;m using my home NAS, a DiskStation, over NFS. The
only thing we need to do is to share a volume over NFS and install NFS on our
nodes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo apt-get -y install nfs-common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we need to create a &lt;code&gt;PersistentVolume&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-gogs
spec:
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Recycle
  nfs:
    path: /volume1/kbn1/gogs
    server: my-nfs-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then a &lt;code&gt;PersistentVolumeClaim&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pvc-gogs
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and lastly mount the volume in our pod template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: ReplicationController
metadata:
  labels:
    app: gogs
  name: gogs
  namespace: default
spec:
  replicas: 1
  selector:
    app: gogs
  template:
    metadata:
      labels:
        app: gogs
    spec:
      containers:
      - image: larmog/rpi-gogs:0.8.23.0126-2
        imagePullPolicy: IfNotPresent
        name: gogs
        volumeMounts:
        - mountPath: &amp;quot;/data&amp;quot;
          name: persistentdata
        resources: {}
        ports:
          - containerPort: 3000
            name: web   
            protocol: TCP
          - containerPort: 22
            name: ssh
            protocol: TCP
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      terminationGracePeriodSeconds: 30
      volumes:
        - name: persistentdata
          persistentVolumeClaim:
            claimName: pvc-gogs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NFS v4 is kind of hard to use if you don&amp;rsquo;t have synchronized your users and
groups in your domain. I use &lt;code&gt;all_squash&lt;/code&gt; to a specific UID/GID in order to get
it to work with my NAS, and that works fine for Gogs but I&amp;rsquo;ve got plans to
replace NFS with &lt;a href=&#34;https://www.gluster.org/&#34;&gt;GlusterFS&lt;/a&gt; and it&amp;rsquo;s on the &lt;code&gt;TODO&lt;/code&gt;
list.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s enjoy the fruit of our work (or as we say in Sweden: &amp;ldquo;ett Ernst ögonblick&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ kubectl get services
NAME         CLUSTER_IP   EXTERNAL_IP   PORT(S)    SELECTOR       AGE
my-gogs      10.0.0.85    &amp;lt;none&amp;gt;        80/TCP     app=gogs       9d
my-gogs-ssh  10.0.0.216   nodes         2222/TCP   app=gogs       9d
kubernetes   10.0.0.1     &amp;lt;none&amp;gt;        443/TCP    &amp;lt;none&amp;gt;         25d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that I&amp;rsquo;ve also created a service for the &lt;code&gt;ssh&lt;/code&gt; port.
Now we can complete the Gogs installation. Open the url (http://[master-ip]:8080/api/v1/proxy/namespaces/default/services/my-gogs-service)
and complete the installation.&lt;/p&gt;

&lt;p&gt;In the next part I will explain how to set up &lt;code&gt;service-loadbalancer&lt;/code&gt; to
expose your services outside your cluster.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Kubernetes On ARM</title>
      <link>http://larmog.github.io/2016/02/06/kubernetes-on-arm/</link>
      <pubDate>Sat, 06 Feb 2016 10:33:08 +0100</pubDate>
      
      <guid>http://larmog.github.io/2016/02/06/kubernetes-on-arm/</guid>
      <description>&lt;p&gt;I really like Kubernetes for orchestrating Docker containers. If you&amp;rsquo;re don&amp;rsquo;t
familiar with Kubernetes I can highly recommend to take a look at
(&lt;a href=&#34;http://kubernetes.io&#34;&gt;http://kubernetes.io&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;You can easily run you&amp;rsquo;re own Kubernetes cluster on your local machine using
Vagrant or run Kubernetes in the cloud using AWS, Azure or Google Compute.
But I like a more hands on solution and I always wanted my own &amp;ldquo;data center&amp;rdquo;.
On the other hand I don&amp;rsquo;t want to spend a fortune building a DC just for fun.&lt;/p&gt;

&lt;p&gt;A great alternative is to use ARM SoC boards like Raspberry PI. Thank&amp;rsquo;s to
&lt;a href=&#34;https://github.com/luxas&#34;&gt;Lucas Käldström&lt;/a&gt; and
&lt;a href=&#34;http://blog.hypriot.com/&#34;&gt;Hypriot&lt;/a&gt; this is a rather straight forward process.&lt;/p&gt;

&lt;p&gt;I used the &lt;code&gt;hypriotos&lt;/code&gt; image and Lucas &lt;code&gt;deb&lt;/code&gt;-package to install &lt;code&gt;kube-config&lt;/code&gt;.&lt;/p&gt;


&lt;figure&gt;
  &lt;div class=&#34;card blue-grey teal lighten-5&#34;&gt;
    &lt;div class=&#34;card-content black-text&#34;&gt;
      
      &lt;figcaption&gt;
          &lt;span class=&#34;card-title black-text&#34;&gt;Six Raspberry Pi:s in a cluster&lt;/span&gt;
          
      &lt;/figcaption&gt;
      
      
          &lt;img class=&#34;responsive-img&#34; src=&#34;http://larmog.github.io/media/IMG_1936.png&#34;  /&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/figure&gt;



&lt;p&gt;
&lt;figure&gt;
  &lt;div class=&#34;card blue-grey teal lighten-5&#34;&gt;
    &lt;div class=&#34;card-content black-text&#34;&gt;
      
      &lt;figcaption&gt;
          &lt;span class=&#34;card-title black-text&#34;&gt;Nodes in my cluster&lt;/span&gt;
          &lt;p&gt;
          Here you can see the nodes in the cluster. I&amp;#39;m using the service-loadbalancer addon (a topic for another post).
          
              
          
        &lt;/p&gt; 
      &lt;/figcaption&gt;
      
      
          &lt;img class=&#34;responsive-img&#34; src=&#34;http://larmog.github.io/media/k8s.png&#34; alt=&#34;Here you can see the nodes in the cluster. I&amp;#39;m using the service-loadbalancer addon (a topic for another post).&#34; /&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/figure&gt;

&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Thank you Java, but it&#39;s time to Go</title>
      <link>http://larmog.github.io/2016/02/04/thank-you-java-but-its-time-to-go/</link>
      <pubDate>Thu, 04 Feb 2016 20:56:35 +0100</pubDate>
      
      <guid>http://larmog.github.io/2016/02/04/thank-you-java-but-its-time-to-go/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been a dedicated Java developer since 1998 and it&amp;rsquo;s been a great tool.
But recently there&amp;rsquo;s a couple of things I&amp;rsquo;ve been fretting about. I always been
slow using keyboard (never learnt how to use it correctly). When programming
that&amp;rsquo;s not always a bad thing, it gives you time to think about what you&amp;rsquo;re
writing.
But Java is very verbose and all those &lt;code&gt;private&lt;/code&gt;, &lt;code&gt;pubic&lt;/code&gt;, &lt;code&gt;;&lt;/code&gt;, &lt;code&gt;getXXX&lt;/code&gt;,
&lt;code&gt;setXXX&lt;/code&gt; kind of gets in the way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another thing that turns out to be complicated is coding standards. It&amp;rsquo;s all
well when your on a greenfield project and the team can decide their own rules.
But have you ever worked with legacy code that&amp;rsquo;s been abused for several years
buy developers who rather wish they were on that super cool project? I know you
can&amp;rsquo;t blame &lt;code&gt;Java&lt;/code&gt; for this but it&amp;rsquo;s still a problem. Coding standards are like
fashion and every developer has an opinion on where to put the &lt;code&gt;{}&lt;/code&gt; and don&amp;rsquo;t
mention line endings when your in a mixed Windows and *nix environment.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Gofmt is a tool that automatically formats Go source code
$go fmt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Java was released in 1995 the promise &lt;em&gt;&amp;ldquo;write once, run anywhere&amp;rdquo;&lt;/em&gt; sounded
very tempting but has shown not to be altogether true. There have been, and
will always be, bugs and small differences in the JVM which means that your
program will always be dependent on the version of the JVM running your byte
code. That means you have at least two artifacts to consider and
one of them is out of your control.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Static compiled go binary that can be used in a Docker image.
# The binary is compiled using golang Docker image.
$CGO_ENABLED=0 GOOS=linux go build -ldflags &amp;quot;-s&amp;quot; -a -installsuffix cgo -o main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your like me feeling young and haven&amp;rsquo;t aged a day since 1995, the truth is
time goes by. Even if you do your best to keep young, it&amp;rsquo;s hard to change. Java
has done a good job: HotSpot, Regular expressions, NIO, Generics, Annotations,
primitive wrapper classes with autoboxing, Enumerations, Varargs and Lambda
Expressions. Just take a look at the
&lt;a href=&#34;https://en.wikipedia.org/wiki/Java_version_history&#34;&gt;Java version history&lt;/a&gt;. But
all this adds up and gains weight. Java has become hard to learn and understand
and there are many pitfalls and compromises. Some times the right decision is
to start all over and make something new based on what you&amp;rsquo;ve learnt.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# OSX
$open http://tour.golang.org/welcome/1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m keeping Java in my toolbox but I&amp;rsquo;ve started using
&lt;a href=&#34;https://golang.org/&#34;&gt;The Go Programming Language&lt;/a&gt; as my new tool and
it&amp;rsquo;s great fun.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Simple Groovy AOP using MOP</title>
      <link>http://larmog.github.io/2014/08/18/simple-groovy-aop-using-mop/</link>
      <pubDate>Mon, 18 Aug 2014 21:37:45 +0100</pubDate>
      
      <guid>http://larmog.github.io/2014/08/18/simple-groovy-aop-using-mop/</guid>
      <description>&lt;p&gt;I was looking for a simple solution for adding cross cutting concerns to Groovy
classes. The most obvious solution was to implement &lt;code&gt;GroovyInterceptable&lt;/code&gt; but I wanted a
less intrusive solution. After a bit of googling I&amp;rsquo;ve stumbled across
&lt;code&gt;DelegatingMetaClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is a simple interceptor that works like a around advice. It only logs all method
calls for a class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Interceptor extends DelegatingMetaClass {
  	Interceptor(final Class cls) {
      	super(cls)
      	initialize()
  	}

  	public Object invokeMethod(Object obj, String method, Object[] args) {
      	String cls = obj.class.simpleName
      	println &amp;quot;before: $cls.$method, args:$args --&amp;gt;&amp;quot;
      	def val = null
      	try {
          	val = super.invokeMethod(obj, method, args)
      	} catch(Exception e) {
          	println &amp;quot;after: $cls.$method, has thrown:$e &amp;lt;--&amp;quot;
          	throw e
      	}
      	println &amp;quot;after: $cls.$method, return value:$val &amp;lt;--&amp;quot;
      	return val;
  	}

  	def static injectIn(Class cls) {
      	cls.metaClass = new Interceptor(cls)
  	}
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now use the &lt;code&gt;Interceptor&lt;/code&gt; to trace calls to &lt;code&gt;ArrayList&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	Interceptor.InjectIn(ArrayList)

	def list = []
	list &amp;lt;&amp;lt; &amp;quot;Joe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we run the above it will produce:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;	before: ArrayList.leftShift, args:[Joe] --&amp;gt;
	after: ArrayList.leftShift, return value:[Joe] &amp;lt;--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works width mixin&amp;rsquo;s too, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	class Person {
		def name

		def sayHello() { println &amp;quot;Hi, my name is $name!&amp;quot;}
	}

	class Dancer {
		def dance() { println &amp;quot;I can dance&amp;quot; }
	}

	class Singer {
		def sing() { println &amp;quot;I can sing&amp;quot; }
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now create a person who dance and sing. The &lt;code&gt;Interceptor&lt;/code&gt; must be injected
after the mixin:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;	Person.mixin Singer
	Person.mixin Dancer
	Interceptor.injectIn(Person)

	def p = new Person(name: &amp;quot;Jill&amp;quot;)
	p.sayHello()
	p.sing()
	p.dance()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will produce the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;	before: Person.sayHello, args:[] --&amp;gt;
	before: Person.println, args:[Hi, my name is Jill!] --&amp;gt;
	Hi, my name is Jill!
	after: Person.println, return value:null &amp;lt;--
	after: Person.sayHello, return value:null &amp;lt;--
	before: Person.sing, args:[] --&amp;gt;
	I can sing
	after: Person.sing, return value:null &amp;lt;--
	before: Person.dance, args:[] --&amp;gt;
	I can dance
	after: Person.dance, return value:null &amp;lt;--
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As we can see in the example above the &lt;code&gt;println&lt;/code&gt;-method is part of the Groovy object.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>